## AI API Middleware — Copilot instructions

Be concise and prioritize small, safe edits. This file highlights the project's structure, run/debug commands, and patterns an AI coding agent should know to be productive immediately.

- Project type: Flask web app (single-process), small SQLite DB, and a proxy for external AI APIs.
- Key locations:
  - `main.py` — app entrypoint and Flask app registration (registers blueprints + Swagger).
  - `app/` — main package. Important modules:
    - `app/proxy.py` — central proxy logic and request transformation (provider detection, header rewriting, failover, response streaming). Modify here for routing/format changes.
    - `app/database.py` — `KeyManager` handles key rotation, stats, and DB migrations. Thread-safe (uses a lock). Changing key/rotation logic belongs here.
    - `app/api_routes.py` — admin API endpoints (keys, logs, stats). Use these endpoints for automated tests or API-level integration.
    - `app/auth.py` — session-based auth using `MIDDLEWARE_PASSWORD`. If unset, auth is bypassed (useful for local testing).
    - `app/logging_utils.py` — in-memory `live_log` deque used by the dashboard for recent events.
    - `app/config.py` — small config file; note `SECRET_KEY` is generated at runtime with `os.urandom(24)` (sessions will not persist across restarts).

- Run / debug quickly:
  - Local Python: `python main.py` (app listens on PORT env var, default 5000).
  - Docker: `docker-compose up -d` (project contains `Dockerfile` and `docker-compose.yml`).
  - Requirements: `pip install -r requirements.txt` (packages: Flask, requests, python-dotenv, flasgger).

- Important runtime behaviors to preserve in edits:
  - Proxy format detection: `proxy.py` inspects path/body to decide `provider_format` (gemini vs openai). Keep that logic consistent when adding endpoints.
  - Authorization header mapping: for OpenAI-like requests the code sets `Authorization: Bearer <key>`, otherwise it sets `x-goog-api-key`.
  - Failover & key lifecycle: `KeyManager.get_next_key()` rotates keys and updates `last_rotated_at`; `update_key_stats()` marks keys as `Resting` (on 429 for 60s) or `Disabled` (on 400/401/403). Tests or changes must account for these state transitions.
  - Database: SQLite file at `data/keys.db`. `KeyManager` creates DB/tables and migrates from env var `GEMINI_API_KEYS` on first run.

- Testing notes / examples to include when modifying code:
  - Dashboard and API docs: Swagger UI at `/middleware/swagger/` (auto-generated by flasgger). Use it to exercise admin APIs.
  - Login: `/middleware/login` (set `MIDDLEWARE_PASSWORD` in `.env` to enable auth). When `MIDDLEWARE_PASSWORD` is unset, routes guarded by `login_required` bypass auth — useful for CI.
  - Proxy example (from README): `POST http://localhost:5000/v1/models/gemini-pro:generateContent` with JSON body containing `contents`.

- Conventions & constraints discovered in codebase:
  - Use blueprint-based edits (don't change global route registration in `main.py` unless adding a new blueprint).
  - Avoid changing the session `SECRET_KEY` behavior silently — it's intentionally generated, and changing it affects running sessions.
  - Database migrations are manual in `KeyManager._initialize_db()`. If adding columns, follow the existing safe-add `PRAGMA table_info` pattern.
  - Logging for dashboard uses `live_log` (deque maxlen=50). For persistent logs, add storage explicitly rather than modifying the deque.

- When proposing changes, include:
  - Files to edit and the small rationale (1–2 lines).
  - Quick test steps (curl or requests snippet) referencing the exact endpoint (e.g., `/v1/models/<model>:generateContent` or `/middleware/api/keys`).

If anything above is unclear or you want more examples (unit tests, database migration example, or a sample integration test for the proxy), tell me which part you'd like expanded.
